{"version":3,"file":"angular1_providers.js","sourceRoot":"","sources":["../../../../../modules/@angular/upgrade/src/aot/angular1_providers.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;AAIH,iFAAiF;AACjF,sFAAsF;AACtF,+FAA+F;AAC/F,uDAAuD;AACvD,IAAI,eAAyC,CAAC;AAC9C,mCAAmC,QAAkC;IACnE,eAAe,GAAG,QAAQ,CAAC;AAC7B,CAAC;AACD;IACE,IAAM,QAAQ,GAA6B,eAAe,CAAC;IAC3D,eAAe,GAAG,IAAI,CAAC,CAAE,0CAA0C;IACnE,MAAM,CAAC,QAAQ,CAAC;AAClB,CAAC;AAED,iCAAiC,CAA2B;IAC1D,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;AAC7B,CAAC;AAED,+BAA+B,CAA2B;IACxD,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;AAC3B,CAAC;AAED,6BAA6B,CAA2B;IACtD,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AACzB,CAAC;AAED,OAAO,IAAM,iBAAiB,GAAG;IAC/B,yFAAyF;IACzF,2EAA2E;IAC3E,wCAAwC;IACxC,yFAAyF;IACzF,EAAC,OAAO,EAAE,WAAW,EAAE,UAAU,EAAE,eAAe,EAAC;IACnD,EAAC,OAAO,EAAE,YAAY,EAAE,UAAU,EAAE,gBAAgB,EAAE,IAAI,EAAE,CAAC,WAAW,CAAC,EAAC;IAC1E,EAAC,OAAO,EAAE,UAAU,EAAE,UAAU,EAAE,cAAc,EAAE,IAAI,EAAE,CAAC,WAAW,CAAC,EAAC;IACtE,EAAC,OAAO,EAAE,QAAQ,EAAE,UAAU,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC,WAAW,CAAC,EAAC;CACnE,CAAC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as angular from '../angular_js';\n\n// We have to do a little dance to get the ng1 injector into the module injector.\n// We store the ng1 injector so that the provider in the module injector can access it\n// Then we \"get\" the ng1 injector from the module injector, which triggers the provider to read\n// the stored injector and release the reference to it.\nlet tempInjectorRef: angular.IInjectorService;\nexport function setTempInjectorRef(injector: angular.IInjectorService) {\n  tempInjectorRef = injector;\n}\nexport function injectorFactory() {\n  const injector: angular.IInjectorService = tempInjectorRef;\n  tempInjectorRef = null;  // clear the value to prevent memory leaks\n  return injector;\n}\n\nexport function rootScopeFactory(i: angular.IInjectorService) {\n  return i.get('$rootScope');\n}\n\nexport function compileFactory(i: angular.IInjectorService) {\n  return i.get('$compile');\n}\n\nexport function parseFactory(i: angular.IInjectorService) {\n  return i.get('$parse');\n}\n\nexport const angular1Providers = [\n  // We must use exported named functions for the ng2 factories to keep the compiler happy:\n  // > Metadata collected contains an error that will be reported at runtime:\n  // >   Function calls are not supported.\n  // >   Consider replacing the function or lambda with a reference to an exported function\n  {provide: '$injector', useFactory: injectorFactory},\n  {provide: '$rootScope', useFactory: rootScopeFactory, deps: ['$injector']},\n  {provide: '$compile', useFactory: compileFactory, deps: ['$injector']},\n  {provide: '$parse', useFactory: parseFactory, deps: ['$injector']}\n];\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}