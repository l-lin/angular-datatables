{"version":3,"file":"upgrade_module.js","sourceRoot":"","sources":["../../../../../modules/@angular/upgrade/src/aot/upgrade_module.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModule, NgZone, Testability} from '@angular/core';\n\nimport * as angular from '../angular_js';\nimport {controllerKey} from '../util';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {$$TESTABILITY, $DELEGATE, $INJECTOR, $PROVIDE, $ROOT_SCOPE, INJECTOR_KEY, UPGRADE_MODULE_NAME} from './constants';\n\n\n\n/**\n * @whatItDoes\n *\n * *Part of the [upgrade/static](/docs/ts/latest/api/#!?query=upgrade%2Fstatic)\n * library for hybrid upgrade apps that support AoT compilation*\n *\n * Allows Angular 1 and Angular 2+ components to be used together inside a hybrid upgrade\n * application, which supports AoT compilation.\n *\n * Specifically, the classes and functions in the `upgrade/static` module allow the following:\n * 1. Creation of an Angular 2+ directive that wraps and exposes an Angular 1 component so\n *    that it can be used in an Angular 2 template. See {@link UpgradeComponent}.\n * 2. Creation of an Angular 1 directive that wraps and exposes an Angular 2+ component so\n *    that it can be used in an Angular 1 template. See {@link downgradeComponent}.\n * 3. Creation of an Angular 2+ root injector provider that wraps and exposes an Angular 1\n *    service so that it can be injected into an Angular 2+ context. See\n *    {@link UpgradeModule#upgrading-an-angular-1-service Upgrading an Angular 1 service} below.\n * 4. Creation of an Angular 1 service that wraps and exposes an Angular 2+ injectable\n *    so that it can be injected into an Angular 1 context. See {@link downgradeInjectable}.\n * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks\n *    coexisting in a single application. See the\n *    {@link UpgradeModule#example example} below.\n *\n * ## Mental Model\n *\n * When reasoning about how a hybrid application works it is useful to have a mental model which\n * describes what is happening and explains what is happening at the lowest level.\n *\n * 1. There are two independent frameworks running in a single application, each framework treats\n *    the other as a black box.\n * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\n *    instantiated the element is the owner. Each framework only updates/interacts with its own\n *    DOM elements and ignores others.\n * 3. Angular 1 directives always execute inside the Angular 1 framework codebase regardless of\n *    where they are instantiated.\n * 4. Angular 2+ components always execute inside the Angular 2+ framework codebase regardless of\n *    where they are instantiated.\n * 5. An Angular 1 component can be \"upgraded\"\" to an Angular 2+ component. This is achieved by\n *    defining an Angular 2+ directive, which bootstraps the Angular 1 component at its location\n *    in the DOM. See {@link UpgradeComponent}.\n * 6. An Angular 2+ component can be \"downgraded\"\" to an Angular 1 component. This is achieved by\n *    defining an Angular 1 directive, which bootstraps the Angular 2+ component at its location\n *    in the DOM. See {@link downgradeComponent}.\n * 7. Whenever an \"upgraded\"/\"downgraded\" component is instantiated the host element is owned by\n *    the framework doing the instantiation. The other framework then instantiates and owns the\n *    view for that component.\n *    a. This implies that the component bindings will always follow the semantics of the\n *       instantiation framework.\n *    b. The DOM attributes are parsed by the framework that owns the current template. So\n * attributes\n *       in Angular 1 templates must use kebab-case, while Angular 1 templates must use camelCase.\n *    c. However the template binding syntax will always use the Angular 2+ style, e.g. square\n *       brackets (`[...]`) for property binding.\n * 8. Angular 1 is always bootstrapped first and owns the root component.\n * 9. The new application is running in an Angular 2+ zone, and therefore it no longer needs calls\n * to\n *    `$apply()`.\n *\n * @howToUse\n *\n * `import {UpgradeModule} from '@angular/upgrade/static';`\n *\n * ## Example\n * Import the {@link UpgradeModule} into your top level {@link NgModule Angular 2+ `NgModule`}.\n *\n * {@example upgrade/static/ts/module.ts region='ng2-module'}\n *\n * Then bootstrap the hybrid upgrade app's module, get hold of the {@link UpgradeModule} instance\n * and use it to bootstrap the top level [Angular 1\n * module](https://docs.angularjs.org/api/ng/type/angular.Module).\n *\n * {@example upgrade/static/ts/module.ts region='bootstrap'}\n *\n *\n * ## Upgrading an Angular 1 service\n *\n * There is no specific API for upgrading an Angular 1 service. Instead you should just follow the\n * following recipe:\n *\n * Let's say you have an Angular 1 service:\n *\n * {@example upgrade/static/ts/module.ts region=\"ng1-title-case-service\"}\n *\n * Then you should define an Angular 2+ provider to be included in your {@link NgModule} `providers`\n * property.\n *\n * {@example upgrade/static/ts/module.ts region=\"upgrade-ng1-service\"}\n *\n * Then you can use the \"upgraded\" Angular 1 service by injecting it into an Angular 2 component\n * or service.\n *\n * {@example upgrade/static/ts/module.ts region=\"use-ng1-upgraded-service\"}\n *\n * @description\n *\n * This class is an `NgModule`, which you import to provide Angular 1 core services,\n * and has an instance method used to bootstrap the hybrid upgrade application.\n *\n * ## Core Angular 1 services\n * Importing this {@link NgModule} will add providers for the core\n * [Angular 1 services](https://docs.angularjs.org/api/ng/service) to the root injector.\n *\n * ## Bootstrap\n * The runtime instance of this class contains a {@link UpgradeModule#bootstrap `bootstrap()`}\n * method, which you use to bootstrap the top level Angular 1 module onto an element in the\n * DOM for the hybrid upgrade app.\n *\n * It also contains properties to access the {@link UpgradeModule#injector root injector}, the\n * bootstrap {@link NgZone} and the\n * [Angular 1 $injector](https://docs.angularjs.org/api/auto/service/$injector).\n *\n * @experimental\n */\n\nexport class UpgradeModule {\n  /**\n   * The Angular 1 `$injector` for the upgrade application.\n   */\n  public $injector: any /*angular.IInjectorService*/;\n\n  constructor(\n      /** The root {@link Injector} for the upgrade application. */\n      public injector: Injector,\n      /** The bootstrap zone for the upgrade application */\n      public ngZone: NgZone) {}\n\n  /**\n   * Bootstrap an Angular 1 application from this NgModule\n   * @param element the element on which to bootstrap the Angular 1 application\n   * @param [modules] the Angular 1 modules to bootstrap for this application\n   * @param [config] optional extra Angular 1 bootstrap configuration\n   */\n  bootstrap(\n      element: Element, modules: string[] = [], config?: any /*angular.IAngularBootstrapConfig*/) {\n    // Create an ng1 module to bootstrap\n    const upgradeModule =\n        angular\n            .module(UPGRADE_MODULE_NAME, modules)\n\n            .value(INJECTOR_KEY, this.injector)\n\n            .config([\n              $PROVIDE, $INJECTOR,\n              ($provide: angular.IProvideService, $injector: angular.IInjectorService) => {\n                if ($injector.has($$TESTABILITY)) {\n                  $provide.decorator($$TESTABILITY, [\n                    $DELEGATE,\n                    (testabilityDelegate: angular.ITestabilityService) => {\n                      const originalWhenStable: Function = testabilityDelegate.whenStable;\n                      const injector = this.injector;\n                      // Cannot use arrow function below because we need the context\n                      const newWhenStable = function(callback: Function) {\n                        originalWhenStable.call(this, function() {\n                          const ng2Testability: Testability = injector.get(Testability);\n                          if (ng2Testability.isStable()) {\n                            callback.apply(this, arguments);\n                          } else {\n                            ng2Testability.whenStable(newWhenStable.bind(this, callback));\n                          }\n                        });\n                      };\n\n                      testabilityDelegate.whenStable = newWhenStable;\n                      return testabilityDelegate;\n                    }\n                  ]);\n                }\n              }\n            ])\n\n            .run([\n              $INJECTOR,\n              ($injector: angular.IInjectorService) => {\n                this.$injector = $injector;\n\n                // Initialize the ng1 $injector provider\n                setTempInjectorRef($injector);\n                this.injector.get($INJECTOR);\n\n                // Put the injector on the DOM, so that it can be \"required\"\n                angular.element(element).data(controllerKey(INJECTOR_KEY), this.injector);\n\n                // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n                const $rootScope = $injector.get('$rootScope');\n                this.ngZone.onMicrotaskEmpty.subscribe(\n                    () => this.ngZone.runOutsideAngular(() => $rootScope.$evalAsync()));\n              }\n            ]);\n\n    // Make sure resumeBootstrap() only exists if the current bootstrap is deferred\n    const windowAngular = (window as any /** TODO #???? */)['angular'];\n    windowAngular.resumeBootstrap = undefined;\n\n    // Bootstrap the angular 1 application inside our zone\n    this.ngZone.run(() => { angular.bootstrap(element, [upgradeModule.name], config); });\n\n    // Patch resumeBootstrap() to run inside the ngZone\n    if (windowAngular.resumeBootstrap) {\n      const originalResumeBootstrap: () => void = windowAngular.resumeBootstrap;\n      const ngZone = this.ngZone;\n      windowAngular.resumeBootstrap = function() {\n        let args = arguments;\n        windowAngular.resumeBootstrap = originalResumeBootstrap;\n        ngZone.run(() => { windowAngular.resumeBootstrap.apply(this, args); });\n      };\n    }\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: NgModule, args: [{providers: angular1Providers}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: ({type: any, decorators?: DecoratorInvocation[]}|null)[] = [\n{type: Injector, },\n{type: NgZone, },\n];\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}